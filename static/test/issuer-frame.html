<!DOCTYPE html>
<meta charset="utf-8">
<title>Unit Tests</title>
<link rel="stylesheet" href="qunit.css">
<h1 id="qunit-header">Unit Tests</h1>
<h2 id="qunit-banner"></h2>
<div id="qunit-testrunner-toolbar"></div>
<h2 id="qunit-userAgent"></h2>
<ol id="qunit-tests"></ol>
<div id="qunit-fixture"></div>
<script src="qunit.js"></script>
<script src="../js/jquery.min.js"></script>
<script src="../js/underscore-min.js"></script>
<script src="../js/backbone-min.js"></script>
<script>

jQuery.extend({
  meta: function(name, value) {
    return $("meta[http-equiv='" + name + "']").attr("content", value);
  }
});

var Session = function(spec) {
  var spec = spec || {};

  var startLogin = spec.startLogin || function(deferred) {
    navigator.id.getVerifiedEmail(function(assertion) {
      jQuery.ajax({
	url: '/backpack/authenticate',
	type: 'POST',
	dataType: 'json',
	data: {assertion: assertion},
	success: function(data) {
	  deferred.resolve(data);
	},
	error: function() {
	  deferred.reject();
	}
      });
    });
  };

  var loginStarted = false;
  var Session = {
    CSRF: jQuery.meta("X-CSRF-Token"),
    currentUser: jQuery.meta("X-Current-User"),
    login: function() {
      if (!loginStarted) {
	var login = jQuery.Deferred();
	login.done(function(data) {
	  Session.currentUser = data.email;
	  Session.trigger("login-complete");
	});
	login.fail(function() {
	  Session.trigger("login-error");
	});
	login.always(function() {
	  loginStarted = false;
	});
	loginStarted = true;
	Session.trigger('login-started');
	startLogin(login);
      }
    }
  };

  _.extend(Session, Backbone.Events);

  jQuery.ajaxSetup({
    beforeSend: function (xhr, settings) {
      if (!settings.crossDomain && settings.type != "GET")
	xhr.setRequestHeader('X-CSRF-Token', Session.CSRF)
    }
  });

  return Session;
};

module("Session");

test('Session.currentUser from &lt;meta http-equiv="X-Current-User"&gt;', function() {
  ok(!Session().currentUser, "No current user");
  $('<meta http-equiv="X-Current-User" content="example@example.com">').appendTo($('body'));
  equal(Session().currentUser, 'example@example.com', "Current user grabbed from meta http-equiv=\"X-Current-User\"");
});

asyncTest('Session.login failure', function(){
  var s = Session({
    startLogin: function(deferred){
      // Always fail
      deferred.reject();
    }
  });
  var started = false;
  s.on('login-started', function(){
    started = true;
  });
  s.on('login-error', function(){
    ok(started, 'Saw login-started');
    ok(true, 'Saw login-error');
    start();
  });
  s.on('login-complete', function(){
    ok(false, 'Saw login-complete');
    start();
  });
  s.login();
});

asyncTest('Session.login success', function(){
  var s = Session({
    startLogin: function(deferred){
      // Always succeed
      deferred.resolve({email: 'foo@example.com'});
    }
  });
  var started = false;
  s.on('login-started', function(){
    started = true;
  });
  s.on('login-error', function(){
    ok(false, 'Saw login-error');
    start();
  });
  s.on('login-complete', function(){
    ok(started, 'Saw login-started');
    ok(true, 'Saw login-complete');
    equal(s.currentUser, 'foo@example.com', 'currentUser set');
    start();
  });
  s.login();
});

</script>
<script>

/* Badge - an evented Deferred representing a badge
 *   Takes an assertion url
 *   Optionally takes build and issue methods in a spec object
 *     These should return Deferreds or plain objects
 *     `build` attempts to build a full badge out of the assertion url
 *     `issue` attempts to issue the badge
 *
 *   Events:
 *     built   - fired when build succeeds
 *     issued  - fired when issue succeeds
 *
 *   The Deferred is resolved if build and issue succeed, and rejected
 *   if either has an error or the badge is rejected by the user.
 */
var Badge = function(assertion, spec){
  var spec = spec || {};
  var build = spec.build || function(){ return {}; };
  var issue = spec.issue || function(){ return {}; };

  var buildState;
  var issueState;

  var Badge = $.Deferred(function(){
    var _state = 'pendingBuild';
    var _badgeData;

    function changeState(to){
      _state = to;
      Badge.trigger('state-change', to);
    }

    this.assertion = assertion;

    this.error;
    this.fail(function(reason){
      this.error = {url: assertion, reason: reason};
      changeState('failed');
    });

    this.start = function(){
      buildState = build(assertion);

      $.when(buildState).then(
	function buildSuccess(data){
	  _badgeData = data;
	  changeState('built');
	  Badge.trigger('built');
	},
	function buildFailure(data){
	  changeState('failed');
	  Badge.reject(data);
	}
      );
    };

    this.issue = function(){
      if (_state != 'built')
	throw new Error('Cannot issue unbuilt badge');

      changeState('pendingIssue');
      issueState = issue(assertion);

      $.when(issueState).then(
	function issueSuccess(){
	  changeState('issued');
	  Badge.trigger('issued');
	  Badge.resolve();
	},
	function issueFailure(data){
	  changeState('failed');
	  Badge.reject(data);
	}
      );
    };

    this.badgeData = function(){
      return _badgeData;
    };

    this.result = function(){
      var state = this.state();

      if (state === 'issued')
	return this.assertion;
      else if (state === 'failed')
	return this.error;
      else
	throw new Error("Can't return result for state " + state);
    };

    this.state = function(){
      return _state;
    };

    this.isState = function(state){
      return state === _state;
    }

    _.extend(this, Backbone.Events);

  });

  return Badge;
};

module("Badge");

asyncTest('Successful badge', function(){
  var b = Badge('foo', {
    build: function(){ return $.Deferred().resolve(); },
    issue: function(){ return $.Deferred().resolve(); }
  });
  b.on('built', function(){
    this.issue();
  });
  b.done(function(){
    ok(true, 'done');
  });
  b.fail(function(){
    ok(false, 'fail');
  });
  b.always(function(){
    equal(this.state(), 'issued');
    equal(this.assertion, 'foo');
    start();
  });
  b.start();
});

asyncTest('Failed build', function(){
  var b = Badge('foo', {
    build: function(){ return $.Deferred().reject('asplode'); }
  });
  b.on('built', function(){
    ok(false, 'should not see built event');
    start();
  });
  b.done(function(){
    ok(false, 'done');
  });
  b.fail(function(){
    ok(true, 'fail');
  });
  b.always(function(){
    equal(this.state(), 'failed');
    deepEqual(this.error, {url: 'foo', reason: 'asplode'});
    start();
  });
  b.start();
});

asyncTest('Failed issue', function(){
  b = Badge('foo', {
    build: function(){ return $.Deferred().resolve(); },
    issue: function(){ return $.Deferred().reject('asplode'); }
  });
  var built = false;
  b.on('built', function(){
    built = true;
    b.issue();
  });
  b.done(function(){
    ok(fail, 'fail');
  });
  b.fail(function(){
    ok(true, 'fail');
  });
  b.always(function(){
    ok(built, 'saw built event');
    equal(this.state(), 'failed');
    deepEqual(this.error, {url: 'foo', reason: 'asplode'});
    start();
  });
  b.start();
});

asyncTest('User rejected', function(){
  b = Badge('foo');
  b.on('built', function(){
    b.reject('DENIED');
  });
  b.done(function(){
    ok(false, 'done');
  });
  b.fail(function(){
    ok(true, 'fail');
  });
  b.always(function(){
    equal(this.state(), 'failed');
    deepEqual(this.error, {url: 'foo', reason: 'DENIED'});
    start();
  });
  b.start();
});

asyncTest('Successful badge states', function(){
  var build = $.Deferred();
  var issue = $.Deferred();

  var b = Badge('foo', {
    build: function(){ return build; },
    issue: function(){ return issue; }
  });
  var states = [];
  states.push(b.state());
  b.on('built', function(){
    states.push(b.state());
    b.issue();
    states.push(b.state());
    issue.resolve();
  });
  b.on('issued', function(){
    states.push(b.state());
  });
  var stateChanges = 0;
  b.on('state-change', function(){
    stateChanges++;
  });
  b.always(function(){
    equal(stateChanges, 3);
    deepEqual(states, ['pendingBuild', 'built', 'pendingIssue', 'issued']);
    start();
  });
  b.start();
  build.resolve();
});

asyncTest('Badge events', function(){
  var b = Badge('foo');
  var events = [];
  b.on('built', function(){
    events.push('built');
    b.issue();
  });
  b.on('issued', function(){
    events.push('issued');
  });
  b.always(function(){
    deepEqual(events, ['built', 'issued'], 'saw both');
    start();
  });
  b.start();
});

asyncTest('result for issued', function(){
  var b = Badge('foo');
  b.on('built', function(){
    b.issue();
  });
  b.start();
  b.always(function(){
    equal(this.result(), 'foo');
    start();
  });
});

asyncTest('result for failed', function(){
  var b = Badge('foo', {
    build: function(){ return $.Deferred().reject('asplode'); }
  });
  b.start();
  b.always(function(){
    deepEqual(this.result(), {url: 'foo', reason: 'asplode'});
    start();
  });
});

asyncTest('Badge data', function(){
  var b = Badge('foo', {
    build: function(assertion){ return {url: assertion, extra: 'stuff'}; }
  });
  equal(b.badgeData(), undefined);
  b.on('built', function(){
    deepEqual(b.badgeData(), {url: 'foo', extra: 'stuff'});
    start();
  });
  b.start();
});

</script>
<script>

var App = function(assertions, spec){
  var assertions = assertions || [];
  var spec = spec || {};
  var build = spec.build || function(){ return $.Deferred().resolve(); };
  var issue = spec.issue || function(){ return $.Deferred().resolve(); };

  var badges = [];

  var App = {
    start: function(){
      if (assertions.length === 0) {
	App.trigger('badges-complete', [], [], 0);
      }
      else {
	assertions.forEach(function(assertion, i, arr){
	  var b = Badge(assertion, {
	    build: build,
	    issue: issue
	  });
	  b.on('state-change', function(){
	    App.trigger('state-change');
	  });
	  badges.push(b);
	});
	badges.forEach(function(badge, i, arr){
	  badge.start();
	});
      }
    }
  };

  _.extend(App, Backbone.Events);

  function checkAllBuilt() {
    var building = _.find(badges, function(badge){ return badge.state() === 'pendingBuild'; });
    if (!building){
      var built = _.filter(badges, function(badge){ return badge.state() === 'built'; });
      App.off('state-change', checkAllBuilt);
      if (built.length > 0) {
	App.trigger('badges-ready', built);
      }
    }
  }

  function checkAllIssued() {
    var nonFinal = _.find(badges, function(badge){ return !(badge.state() === 'issued' || badge.state() === 'failed'); });
    if (!nonFinal) {
      var issuedCount = _.reduce(badges, function(memo, badge){ return badge.state() === 'issued' ? memo + 1 : memo; }, 0);
      App.trigger('badges-issued', issuedCount);
    }
  }

  function checkAllDone() {
    var pending = _.find(badges, function(badge){ return !(badge.isResolved() || badge.isRejected()); });
    if(!pending) {
      var failures = _.map(
	_.filter(badges, function(badge){ return badge.isState('failed'); }),
	function(badge){ return badge.result() }
      );
      var successes = _.map(
	_.filter(badges, function(badge){ return badge.isState('issued'); }),
	function(badge){ return badge.result() }
      );
      App.trigger('badges-complete', failures, successes, badges.length);
    }
  }

  App.on('state-change', checkAllBuilt);
  App.on('state-change', checkAllIssued);
  App.on('state-change', checkAllDone);

  return App;
};

module("App");

function failOne(fail, reason){
  return function(assertion) {
    if (assertion === fail) {
      console.log('failing', assertion);
      return $.Deferred().reject(reason);
    }
    console.log('passing', assertion);
    return $.Deferred().resolve();
  };
}

asyncTest('Run app with no assertions', function(){
  var app = App([]);
  app.on('badges-complete', function(failures, successes, total){
    ok(true, 'badges-complete event');
    deepEqual(failures, [], 'empty failures');
    deepEqual(successes, [], 'empty successes');
    equal(total, 0, '0 total badges');
    start();
  });
  app.start();
});

asyncTest('Accept a badge', function(){
  var app = App(['foo']);
  var ready = false;
  app.on('badges-ready', function(badges){
    ready = true;
    equal(badges.length, 1);
    equal(badges[0].assertion, 'foo');
    badges[0].issue();
  });
  app.on('badges-complete', function(failures, successes, total){
    ok(ready, 'Saw badges-ready event');
    ok(true, 'badges-complete event');
    deepEqual(failures, [], 'empty failures');
    deepEqual(successes, ['foo'], 'foo a success');
    equal(total, 1, '1 total badges');
    start();
  });
  app.start();
});

asyncTest('Reject a badge', function(){
  var app = App(['foo']);
  var ready = false;
  app.on('badges-ready', function(badges){
    ready = true;
    equal(badges.length, 1);
    equal(badges[0].assertion, 'foo');
    badges[0].reject('DENIED');
  });
  app.on('badges-complete', function(failures, successes, total){
    ok(ready, 'Saw badges-ready event');
    ok(true, 'badges-complete event');
    deepEqual(failures, [{url: 'foo', reason: 'DENIED'}], 'foo a failure');
    deepEqual(successes, [], 'empty successes');
    equal(total, 1, '1 total badges');
    start();
  });
  app.start();
});

asyncTest('Bad assertion', function(){
  var app = App(['FAILME'], {
    build: failOne('FAILME', 'you suck')
  });
  app.on('badges-ready', function(badges){
    ok(false, 'no ready event');
    start();
  });
  app.on('badges-complete', function(failures, successes, total){
    deepEqual(failures, [{url: 'FAILME', reason: 'you suck'}], 'FAILME a failure');
    start();
  });
  app.start();
});

asyncTest('Issuing failure', function(){
  var app = App(['HAZIT'], {
    issue: failOne('HAZIT', 'you have that one')
  });
  var ready = false;
  app.on('badges-ready', function(badges){
    ready = true;
    equal(badges.length, 1);
    badges[0].issue();
  });
  app.on('badges-complete', function(failures, successes, total){
    ok(ready, 'Saw badges-ready');
    deepEqual(failures, [{url: 'HAZIT', reason: 'you have that one'}], 'HAZIT a failure');
    start();
  });
  app.start();
});

asyncTest('Two good badges', function(){
  var app = App(['foo', 'bar']);
  app.on('badges-ready', function(badges){
    equal(badges.length, 2, 'two badges ready');
    badges.forEach(function(badge, i, arr){
      badge.issue();
    });
  });
  app.on('badges-complete', function(f, s, t){
    deepEqual(f, [], 'no failures');
    deepEqual(s, ['foo', 'bar'], 'both succeed');
    equal(t, 2);
    start();
  });
  app.start();
});

asyncTest('One good, one bad', function(){
  var app = App(['foo', 'bar'], {
    build: failOne('bar', 'NO BARS!')
  });
  var ready = false;
  app.on('badges-ready', function(badges){
    ready = true;
    equal(badges.length, 1);
    equal(badges[0].assertion, 'foo');
    badges[0].issue();
  });
  app.on('badges-complete', function(f, s, t){
    ok(ready, 'saw ready event');
    deepEqual(f, [{url: 'bar', reason: 'NO BARS!'}], 'bar fails');
    deepEqual(s, ['foo'], 'foo succeeds');
    equal(t, 2);
    start();
  });
  app.start();
});

asyncTest('Two bad', function(){
  var app = App(['foo', 'bar'], {
    build: failOne('bar', "bar won't build"),
    issue: failOne('foo', "foo won't issue")
  });
  app.on('badges-ready', function(badges){
    badges.forEach(function(badge){
      badge.issue();
    });
  });
  app.on('badges-complete', function(f, s, t){
    deepEqual(f, [{url: 'foo', reason: "foo won't issue"}, {url: 'bar', reason: "bar won't build"}]);
    deepEqual(s, []);
    equal(t, 2);
    start();
  });
  app.start();
});
</script>

